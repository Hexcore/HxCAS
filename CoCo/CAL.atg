import library.*;
import java.util.ArrayList;
import java.util.TreeSet;
import com.hexcore.cas.rulesystems.TableEntry;
import com.hexcore.cas.rulesystems.ConstantRecord;
import com.hexcore.cas.rulesystems.SymbolTable;
import com.hexcore.cas.rulesystems.PrimaryPair;
import org.objectweb.asm.Label;

COMPILER CAL $NC

static enum RelOpE{LT, GT, LE, GE, EQ, NE, UN};
static enum AddOpE{ADD, SUB, OR, UN};
static enum MulOpE{MUL, DIV, MOD, AND, UN};
static enum PostOpE{INC, DEC, UN};

static SymbolTable table;
static int typeCountExpected = 0;
static int typeCountActual = 0;
static boolean postOpQueued = false;
static PostOpE postOpType;

static TreeSet<Integer> typeIndices = new TreeSet<Integer>();

static public int getErrorCount()
{
	return Errors.count;
}


static public ArrayList<String> getResult()
{
	ArrayList<String> results = Parser.getErrorList();
	if(Parser.getErrorCount() == 0)
		results.add("Compiled Successfully");
	
	return results;
}


static ArrayList<String> getErrorList()
{
	ArrayList<String> results = new ArrayList<String>();
		
	ErrorRec current = Errors.first;
	
	while(current != null)
	{
		results.add("Error at line " + current.line + ": " + current.str);
		current = current.next;
	}
	
	return results;
}

static byte[] getCode()
{
	return CodeGen.getCode();
}

static public void reset()
{
	errDist = minErrDist;
	Errors.count = 0;
	Errors.first = null;
	Errors.last = null;
	Errors.eof = false;
}

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  lf = CHR(10) .

TOKENS
  number	= digit { digit } .
  double	= digit {digit}"."digit{digit} .
  postInc	= "++" .
  postDec	= "--" .
  
  identifier = letter { letter | digit } .
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE CHR(0) .. CHR(31)


PRODUCTIONS
	/***** File Root *****/
	CAL										(. 	
												table = new SymbolTable();
												typeIndices.clear();
											.)				
  	=
  	RuleSet									(. 	
  												if(typeIndices.size() != typeCountExpected)
  												{
  													SemError("Mismatch between declared and actual type count");
  												}
  												CodeGen.endExecute();
  												CodeGen.endClass();
  											.)						
  	[ColourSet]
  	.
  	
  	
	/***** RuleSet *****/
  	RuleSet									(.
  												String name = "";
  												table.pushScope();
  												table.prepare();
  											.)
  	=
  	"ruleset" Ident< out name >				(. 	CodeGen.initClass(name);
  												CodeGen.initExecute();
  											.)
  	"{"
  	TypeCount
  	Property {Property}
  	TypeSpec {TypeSpec}
  	"}"
  	.
  	
  	
  	TypeCount								(. int value = 0; .)
  	=
  	"typecount" IntConst< out value >		(.
  												if(value < 1)
  												{
  													SemError("At least one type of cell must be declared");
  												}
  												typeCountExpected = value;
  												CodeGen.initFramework(typeCountExpected);
  											.)
  	";"
  	.
  	
  	ColourSet
  	=
  	"colourset" identifier
  	"{"
  		{PropertySpec}
  	"}"
  	.
  	
  	
  	/********** Cell Property **********/
  	Property								(. String name = ""; .)
  	=
  	"property" Ident< out name >			(.
  												if(table.find(name).type != TableEntry.noType) SemError("Identifier \"" + name + "\" already declared.");
  												TableEntry entry = new TableEntry();
  												entry.name = name;
  												entry.type = TableEntry.doubleType;
  												entry.kind = TableEntry.Property;
  												entry.offset = CodeGen.declareProperty();
  												table.insert(entry);
  											.)  
  	";"
  	.
  	/***********************************/
  	
  
  	PropertySpec
  	=
  	"property" identifier
  	"{"
  		RangeSet {RangeSet}
  	"}"
  	.
  	
  	RangeSet								(. int value1, value2; .)
  	=
  	IntConst< out value1 >
   	"to"
   	IntConst< out value2 >
  	":"
  	Colour
  	";"
  	.
  	
  	Colour									(. double value = 0.0;	.)
  	=
  	"rgb("
  	DoubleConst< out value >
  	 "," DoubleConst< out value >
  	 "," DoubleConst< out value >
  	")"
  	.
  
  	
  	
  	TypeSpec								(.
  												int value = 0;
  												table.pushScope();  												
  											.)
  	=
  	"type" identifier ":"
  	IntConst< out value >					(.
  												if(typeIndices.contains(new Integer(value)))
  												{
  													SemError("Duplicate type ID");
  												}
  												if(typeIndices.size() >= typeCountExpected)
  												{
  													SemError("Too many types");
  												}
  												typeIndices.add(new Integer(value));
  												CodeGen.initType();
  											.)
  	"{"
  		{Statement}
  	"}"										(. table.popScope(); CodeGen.endType(); .)
  	.
  	
  	
  	
  	Block 
  	=
  	"{"										(. table.pushScope(); .)
  		{Statement}
  	"}"										(. table.popScope(); .)
  	.
  	
  	
  	/********** STATEMENT **********/
  	Statement
  	=
  	 Block
  	 | AssignCall
  	 | IfStatement
  	 | VarDeclaration 
  	.
  	/*******************************/
  	
  	
  	/********** Assignment or function call *********/
  	AssignCall									(. TableEntry entry = null; int type = TableEntry.noType; int typeA = TableEntry.noType;.)
  	=
  	Designator< out entry >						(. PostOpE T = PostOpE.UN; .)
  	(
  		"=" Expression< out type >				(. 	
  													if(!(TableEntry.isArith(entry.type) && TableEntry.isArith(type)) && !(TableEntry.isBool(entry.type) && TableEntry.isBool(type)))
  													{
  														SemError("Incompatable Types");
  													}
  													else if(!(TableEntry.isArray(entry.type) && TableEntry.isArray(type)) && !(!TableEntry.isArray(entry.type) && !TableEntry.isArray(type)))
  													{
  														SemError("Cannot mix scalar and array types in assignment");
  													}
  													
  													if(entry.kind == TableEntry.Variable)
  													{
  														if(TableEntry.isBool(type))
  														CodeGen.toDouble();
  														CodeGen.storeVariable(entry.offset);
  													}
  													else if(entry.kind == TableEntry.Property)
  													{
  														CodeGen.storeProperty(entry.offset);
  													}
  												.)
  		| PostOp< out T >						(. 
  													if(!TableEntry.isArith(entry.type))
  														SemError("Cannot perform a post operation on a boolan type.");
  														
  													if(entry.kind != TableEntry.Variable)
  													{
  														SemError("Can only perform post operation on a variable.");
  													}
  													else
  													{
  														if(T == PostOpE.INC)
  															CodeGen.performPostOp(entry.offset, 1);
  														else
  															CodeGen.performPostOp(entry.offset, -1);
  													}
  												.)
  		| "(" Arguments< out typeA >			(.	if(!TableEntry.isFunction(entry.kind))
  												{
  													SemError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be an array");
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be a scalar type");
  													}
  												}
  											.)
  		
  		")"
  	)
  	";"
  	.
  	/*************************************************/
  	
  	
  	Designator<. out TableEntry entry .>		(.
  													int type = TableEntry.noType;
  													int typeE = TableEntry.noType;
  													String name = "";
  													TableEntry entryA = null;
  												.)
  	=
  	Ident< out name >							(.

  													entry = table.find(name);
  													if(entry.type == TableEntry.noType)
  														SemError("Undeclared identifier \"" + name + "\"");
  													else
  														type = entry.type;
  												.)
  													 
  	[
  		"["												
  			Expression< out typeE >				(. if((type % 2) == 0) SemError("Cannot index scalar type \"" + name +  "\"");
  													if(!TableEntry.isArith(typeE))
  													{
  														SemError("Index must be arithmetic");
  													}
  												.)
  												
  												
  		"]"										(.
  													if(!TableEntry.isArray(type))
  													{
  														SemError("Can only index arrays");
  													}
  													TableEntry entryS = new TableEntry();
  													entryS.name = entry.name;
  													entryS.kind = entry.kind;
  													entryS.type = entry.type - 1;
  													entry = entryS;
  												.)
  	]
  	[  	
  		"." Attribute< out entryA > 				(.
  														if(entry.kind != TableEntry.Cell) SemError("Only cells have attributes.");
  														if(entryA.kind != TableEntry.Property) SemError("Only declared properties can be used as cell attributes.");
  														TableEntry entryAA = new TableEntry();
  														entryAA.name = entryA.name;
  														entryAA.kind = entryA.kind;
  														entryAA.offset = entryA.offset;
  														if(TableEntry.isArray(entry.type))
  														{
  															entryAA.type = entryA.type + 1;
  														}
  														else
  														{
  															entryAA.type = entryA.type;
  														}
  														
  														entry = entryAA;
  													.)
  	]
  	.
  	
  	
  	
  	Attribute<. out TableEntry entry .>
  	=
  	Designator< out entry >
  	.
  	
  	
  	
  	IfStatement									(. int type = TableEntry.noType; .)
  	=
  	"if" "("
  	Expression< out type > 
  	")"											(. 	Label[] pointers;
  													pointers = CodeGen.initIf();
  												.)
  												
  	Statement									(.
  													CodeGen.jump(pointers[1]); 
  													CodeGen.visitLabel(pointers[0]);
  												.)
  	[
  	"else" Statement							
  	]											(. CodeGen.visitLabel(pointers[1]); .)
  	.
  	
  	
  	
  	VarDeclaration
  	=
 	"var"
	OneVar
	{
	"," OneVar
	}
	";"
	.
  	
  	
  	/********** Expression **********/
  	Expression<. out int type .>			(. 	int type1, type2;
  												type = TableEntry.noType;
  											.)
  	=
  	AddExp< out type1 >						(.
  												RelOpE op = RelOpE.UN;
  												type = type1;
  											.) 
  	[
  	RelOp< out op >							
  	AddExp< out type2 >						(.
  												if(!(TableEntry.isArith(type1) && TableEntry.isArith(type2)) && !(TableEntry.isBool(type1) && TableEntry.isBool(type2)))
  												{
  													SemError("Type mismatch");
  													type = TableEntry.noType;
  												}
  													
  												type = TableEntry.boolType;
  												
  												CodeGen.performRelationalOp(op);										
  											.)
  	]
  	.
  	/********************************/
  	
  	
  	
  	/********** Add-Based Expression **********/
  	AddExp<. out int type .>				(.
  												int type1, type2;
  												type = TableEntry.noType;
  												boolean negative = false;
  											.)
  	=
  	["+" | "-"								(. negative = true; .)
  	]
  	Term< out type1 >						(.
  												AddOpE op = AddOpE.UN;
  												type = type1;
  												
  												if(negative)
  												{
	  												if(!TableEntry.isArith(type1))
	  													SemError("Cannot negate a boolean type");
	  												else
	  													CodeGen.negate();
  												}
  											.)
  	{
  	AddOp< out op > 
  	Term< out type2 >						(.
  												switch(op)
  												{
  													case OR:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;
  												}
  												
  												CodeGen.performAddOp(op);
  											.)
  	}
  	.
  	/******************************************/
  	
  	
  	/********** Terms **********/
  	Term<. out int type .>					(.
  												int type1, type2;
  												type = TableEntry.noType; 
  											.)
  	=
  	Factor< out type1 >						(.
  												MulOpE op = MulOpE.UN;
  												type = type1;
  											.)
  	{
  	MulOp< out op >					
  	Factor< out type2 >						(.
  												switch(op)
  												{
  													case AND:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;  														
  												}
  												
  												CodeGen.performMulOp(op);
  											.)
  	}
  	.
  	/**********************************/
  	
  	
  	
  	/********** Factors **********/
  	Factor<. out int type .>				(.
  												PostOpE T = PostOpE.UN;
  												PrimaryPair p = new PrimaryPair();
  											.)
  	=
  	Primary< out p >						(. type = p.type; .)
  	[
  	PostOp< out T >							(.
  												if(!TableEntry.isArith(type)) SemError("Cannot perform a post operation on a boolan type.");
  												if(p.kind != TableEntry.Variable)
  												{
  													SemError("Can only perform post operations on a variable.");
  												}
												else
												{
													if(T == PostOpE.INC)
													{
														CodeGen.performPostOp(p.offset, 1);
													}
													else
													{
														CodeGen.performPostOp(p.offset, -1);
													}
												}
  											.)
  	]
  	.
  	/*****************************/
  	
  	
  	
  	/********** PRIMARY ELEMENT **********/
  	Primary<. out PrimaryPair p .>			(.
  												p = new PrimaryPair();
  												p.type = TableEntry.noType;
  												
  												int typeA = TableEntry.noType;
  												int typeE = TableEntry.noType;
  												
  												ConstantRecord con;
  												TableEntry entry = null;
  											.)
  	=
  	Designator< out entry >					(.
  												p.type = entry.type;
  												p.kind = TableEntry.Variable;
  												p.offset = entry.offset;
  												
  												if(entry.kind == TableEntry.Variable)
  													CodeGen.derefVariable(entry.offset);
  												else if(entry.kind == TableEntry.Cell)
  													CodeGen.derefRef(entry.offset);
  												else if(entry.kind == TableEntry.Property)
  													CodeGen.derefProperty(entry.offset);						
  											.)
  	[
  	"("		
  		Arguments< out typeA >				(.	
   												if(!TableEntry.isFunction(entry.kind))
  												{
  													SemError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be an array");
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be a scalar type");
  													}
  												}
  												p.kind = TableEntry.Constant;
  											.)
  	")"
  	]										
  	|
  	Constant< out con >						(.
  												p.type = con.type;
  												p.kind = TableEntry.Constant;
  												CodeGen.loadConstant((double)con.value);
  											.)
  	|
  	"(" Expression< out typeE >				(.
  												p.type = typeE;
  												p.kind = TableEntry.Constant;
  											.)
  	")"										
  	.
  	/*************************************/
  	
  	
  	
  	
  	/********** Contant **********/
  	Constant<. out ConstantRecord con .>	(. 	
  												con = new ConstantRecord();
  											.)
  	=
  	DoubleConst< out con.value >			(.	con.type = TableEntry.doubleType;	.)
	| IntConst< out con.value >				(.	con.type = TableEntry.intType;		.)
  	.
  	/*****************************/
  	
  	
  	
  	
  	/********** ARGUMENTS **********/
  	Arguments<. out int type .>				(. type = TableEntry.noType; .)
  	=
  	[
  		Expression< out type >
  		
  		/*
  		Current version support and requirement for only one argument
  		{"," Expression< out type >
  		}*/
  	]
  	.
  	/*******************************/
  	
  	
  	
  	
  	/********** Operators **********/
  	RelOp<. out RelOpE op .>				(. op = RelOpE.UN;	.)
  	=
  	"=="									(. op = RelOpE.EQ;	.)
  	| "!="									(. op = RelOpE.NE;	.)
  	| ">"									(. op = RelOpE.GT;	.)
  	| "<"									(. op = RelOpE.LT;	.)
  	| ">="									(. op = RelOpE.GE;	.)
  	| "<="									(. op = RelOpE.LE;	.)
  	.
  	
  	
  	
  	AddOp<. out AddOpE op .>				(. op = AddOpE.UN;	.)
  	=
  	"+"										(. op = AddOpE.ADD;	.)
  	| "-"									(. op = AddOpE.SUB;	.)
  	| "||"									(. op = AddOpE.OR;	.)
  	.
  	
  	
  	
  	MulOp<. out MulOpE op .>				(. op = MulOpE.UN;	.)
  	=
  	"*"										(. op = MulOpE.MUL;	.)
  	| "/"									(. op = MulOpE.DIV;	.)
  	| "%"									(. op = MulOpE.MOD;	.)
  	| "&&"									(. op = MulOpE.AND;	.)
  	.
  	
  	
  	
  	PostOp<. out PostOpE op .>				(. op = PostOpE.UN;	.)
  	=
  	postInc									(. op = PostOpE.INC;	.)
  	| 
  	postDec									(. op = PostOpE.DEC;	.)
  	.
  	/*******************************/
  	
  	
  	
  	
  	
  	/********** Single Variable **********/
  	OneVar									(. int type = TableEntry.noType; String name = ""; .)
  	=
  	Ident< out name >						(.
  												TableEntry entry = new TableEntry();
  												entry.name = "__new__";
  												
  												if(table.find(name).type != TableEntry.noType) 
  													SemError("Identifier \"" + name + "\" already declared.");
  												else
  												{
  													entry.kind = TableEntry.Variable;
  													entry.name = name;
  													entry.offset = CodeGen.declareLocalVariable(name);
  												}
  											.)
  	[
  	"=" Expression< out type >				(.
  												if(!entry.name.equals("__new__"))
  												{
  													entry.kind = TableEntry.Variable;
  													entry.type = type;
  												}
  												
  												CodeGen.storeVariable(entry.offset);
  											.)
  											
  	]										(.
  												if(!entry.name.equals("__new__"))
  													table.insert(entry);
  											.)
  	.
  	/*************************************/
  	
  	
  	
  	
  	/********** Double Constant **********/
  	DoubleConst<. out double value .>		
  	=
	double									(.
												try
												{
													value = Double.parseDouble(token.val);
												} catch(NumberFormatException e)
												{
													value = 0;
												}
												
											.)
  	.
  	/*************************************/
  	
  	
  	
  	/********** Integer Constant **********/
  	IntConst<. out int value .>
  	=
  	number									(.
  												try
  												{
  													value = Integer.parseInt(token.val);
  												}
  												catch(NumberFormatException e)
  												{
  													value =  0;
  												} 
  											.)
  	.
  	/**************************************/
	
	
	
	/********** Identifier **********/
  	Ident<. out String name .>				(.
  												name = "";
  											.)
  	=
  	identifier								(.
  												name = token.val;
  											.)
  	.
	/********************************/
  	

END CAL.

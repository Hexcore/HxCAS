import library.*;
import java.util.ArrayList;
import com.hexcore.cas.rulesystems.TableEntry;
import com.hexcore.cas.rulesystems.ConstantRecord;
import com.hexcore.cas.rulesystems.SymbolTable;

COMPILER CAL $NC

static enum RelOpE{LT, GT, LE, GE, EQ, NE, UN};
static enum AddOpE{ADD, SUB, OR, UN};
static enum MulOpE{MUL, DIV, MOD, AND, UN};
static enum PostOpE{INC, DEC, UN};

static SymbolTable table;

static public int getErrorCount()
{
	return Errors.count;
}


static public ArrayList<String> getResult()
{
	ArrayList<String> results = Parser.getErrorList();
	if(Parser.getErrorCount() == 0)
		results.add("Compiled Successfully");
	
	return results;
}


static ArrayList<String> getErrorList()
{
	ArrayList<String> results = new ArrayList<String>();
		
	ErrorRec current = Errors.first;
	
	while(current != null)
	{
		results.add("Error at line " + current.line + ": " + current.str);
		current = current.next;
	}
	
	return results;
}

static public void reset()
{
	errDist = minErrDist;
	Errors.count = 0;
	Errors.first = null;
	Errors.last = null;
	Errors.eof = false;
}

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .

TOKENS
  number	= digit { digit } .
  double	= digit {digit}"."digit{digit} .
  postInc	= "++" .
  postDec	= "--" .
  
  identifier = letter { letter | digit } .
  
COMMENTS FROM "/*" TO "*/"

IGNORE CHR(0) .. CHR(31)


PRODUCTIONS
	CAL										(. table = new SymbolTable(); .)
  	=
  	RuleSet
  	[ColourSet]
  	.
  	
  	

  	RuleSet									(.
  												table.pushScope();
  												table.prepare();
  											.)
  	=
  	"ruleset" identifier
  	"{"
  	Property {Property}
  	TypeSpec {TypeSpec}
  	"}"
  	.
  	
  	ColourSet
  	=
  	"colourset" identifier
  	"{"
  		{PropertySpec}
  	"}"
  	.
  	
  	
  	
  	Property								(. String name = ""; .)
  	=
  	"property" Ident< out name >			(.
  												if(table.find(name).type != TableEntry.noType) SemError("Identifier \"" + name + "\" already declared.");
  												TableEntry entry = new TableEntry();
  												entry.name = name;
  												entry.type = TableEntry.doubleType;
  												entry.kind = TableEntry.Property;
  												table.insert(entry);
  											.)  
  	";"
  	.
  	
  
  	PropertySpec
  	=
  	"property" identifier
  	"{"
  		RangeSet {RangeSet}
  	"}"
  	.
  	
  	RangeSet								(. int value1, value2; .)
  	=
  	IntConst< out value1 >
   	"to"
   	IntConst< out value2 >
  	":"
  	Colour
  	";"
  	.
  	
  	Colour									(. double value = 0.0;	.)
  	=
  	"rgb("
  	DoubleConst< out value >
  	 "," DoubleConst< out value >
  	 "," DoubleConst< out value >
  	")"
  	.
  
  	
  	
  	TypeSpec								(.
  												int value = 0;
  												table.pushScope();
  											.)
  	=
  	"type" identifier ":"
  	IntConst< out value >
  	"{"
  		{Statement}
  	"}"										(. table.popScope(); .)
  	.
  	
  	
  	
  	Block 
  	=
  	"{"										(. table.pushScope(); .)
  		{Statement}
  	"}"										(. table.popScope(); .)
  	.
  	
  	
  	/***** STATEMENT *****/
  	Statement
  	=
  	 Block
  	 | AssignCall
  	 | IfStatement
  	 | VarDeclaration 
  	.
  	
  	
  	
  	AssignCall									(. TableEntry entry = null; int type = TableEntry.noType; int typeA = TableEntry.noType;.)
  	=
  	Designator< out entry >						(. PostOpE T = PostOpE.UN; .)
  	(
  		"=" Expression< out type >
  		| PostOp< out T >						(. if(!TableEntry.isArith(entry.type)) SemError("Cannot perform a post operation on a boolan type."); .)
  		| "(" Arguments< out typeA >			(.	if(!TableEntry.isFunction(entry.kind))
  												{
  													SemError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be an array");
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be a scalar type");
  													}
  												}
  											.)
  		
  		")"
  	)
  	";"
  	.
  	
  	
  	
  	Designator<. out TableEntry entry .>		(.
  													int type = TableEntry.noType;
  													int typeE = TableEntry.noType;
  													String name = "";
  													TableEntry entryA = null;
  												.)
  	=
  	Ident< out name >							(.

  													entry = table.find(name);
  													if(entry.type == TableEntry.noType)
  														SemError("Undeclared identifier \"" + name + "\"");
  													else
  														type = entry.type;
  												.)
  													 
  	[
  		"["										(. if((type % 2) == 0) SemError("Cannot index scalar type \"" + name +  "\"");
  													if(!TableEntry.isArith(typeE))
  													{
  														SemError("Index must be arithmetic");
  													}
  												.)		
  			Expression< out typeE >				
  		"]"										(.
  													if(!TableEntry.isArray(type))
  													{
  														SemError("Can only index arrays");
  													}
  													TableEntry entryS = new TableEntry();
  													entryS.name = entry.name;
  													entryS.kind = entry.kind;
  													entryS.type = entry.type - 1;
  													entry = entryS;
  												.)
  	]
  	[  	
  		"." Attribute< out entryA > 				(.
  														if(entry.kind != TableEntry.Cell) SemError("Only cells have attributes.");
  														if(entryA.kind != TableEntry.Property) SemError("Only declared properties can be used as cell attributes.");
  														TableEntry entryAA = new TableEntry();
  														entryAA.name = entryA.name;
  														entryAA.kind = entryA.kind;
  														if(TableEntry.isArray(type))
  														{
  															entryAA.type = entryA.type + 1;
  														}
  														else
  														{
  															entryAA.type = entryA.type;
  														}
  														
  														entry = entryAA;
  													.)
  	]
  	.
  	
  	
  	
  	Attribute<. out TableEntry entry .>
  	=
  	Designator< out entry >
  	.
  	
  	
  	
  	IfStatement									(. int type = TableEntry.noType; .)
  	=
  	"if" "("
  	Expression< out type > 
  	")"
  	Statement
  	[
  	"else" Statement
  	]
  	.
  	
  	
  	
  	VarDeclaration
  	=
 	"var"
	OneVar
	{
	"," OneVar
	}
	";"
	.
  	
  	
  	
  	Expression<. out int type .>			(. 	int type1, type2;
  												type = TableEntry.noType;
  											.)
  	=
  	AddExp< out type1 >						(.
  												RelOpE op = RelOpE.UN;
  												type = type1;
  											.) 
  	[
  	RelOp< out op >							
  	AddExp< out type2 >						(.
  												if(!(TableEntry.isArith(type1) && TableEntry.isArith(type2)) && !(TableEntry.isBool(type1) && TableEntry.isBool(type2)))
  												{
  													SemError("Type mismatch");
  													type = TableEntry.noType;
  												}
  													
  												type = TableEntry.boolType;  												
  											.)
  	]
  	.
  	
  	
  	
  	AddExp<. out int type .>				(.
  												int type1, type2;
  												type = TableEntry.noType;
  												boolean negative = false;
  											.)
  	=
  	["+" | "-"								(. negative = true; .)
  	]
  	Term< out type1 >						(.
  												AddOpE op = AddOpE.UN;
  												type = type1;
  											.)
  	{
  	AddOp< out op > 
  	Term< out type2 >						(.
  												switch(op)
  												{
  													case OR:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;
  												}
  											.)
  	}
  	.
  	
  	
  	
  	Term<. out int type .>					(.
  												int type1, type2;
  												type = TableEntry.noType; 
  											.)
  	=
  	Factor< out type1 >						(.
  												MulOpE op = MulOpE.UN;
  												type = type1;
  											.)
  	{
  	MulOp< out op >					
  	Factor< out type2 >						(.
  												switch(op)
  												{
  													case AND:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;  														
  												}
  											.)
  	}
  	.
  	
  	
  	Factor<. out int type .>				(. PostOpE T = PostOpE.UN; .)
  	=
  	Primary< out type >
  	[
  	PostOp< out T >							(. if(!TableEntry.isArith(type)) SemError("Cannot perform a post operation on a boolan type."); .)
  	]
  	.
  	
  	
  	
  	Primary<. out int type .>				(.
  												type = TableEntry.noType;
  												int typeA = TableEntry.noType;
  												ConstantRecord con;
  												TableEntry entry = null;
  											.)
  	=
  	Designator< out entry >					(.	type = entry.type; .)
  	[
  	"("		
  		Arguments< out typeA >				(.	if(!TableEntry.isFunction(entry.kind))
  												{
  													SemError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be an array");
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemError("Invalid argument. Argument must be a scalar type");
  													}
  												}
  											.)
  	")"
  	]
  	|
  	Constant< out con >						(. type = con.type;  .)
  	|
  	"(" Expression< out type >				
  	")"
  	.
  	
  	
  	
  	Constant<. out ConstantRecord con .>	(. 	
  												con = new ConstantRecord();
  											.)
  	=
  	DoubleConst< out con.value >			(.	con.type = TableEntry.doubleType;	.)
	| IntConst< out con.value >				(.	con.type = TableEntry.intType;		.)
  	.
  	
  	
  	
  	Arguments<. out int type .>								(. type = TableEntry.noType; .)
  	=
  	[
  		Expression< out type >
  		
  		/*
  		Current version support and requirement for only one argument
  		{"," Expression< out type >
  		}*/
  	]
  	.
  	
  	
  	
  	RelOp<. out RelOpE op .>				(. op = RelOpE.UN;	.)
  	=
  	"=="									(. op = RelOpE.EQ;	.)
  	| "!="									(. op = RelOpE.NE;	.)
  	| ">"									(. op = RelOpE.GT;	.)
  	| "<"									(. op = RelOpE.LT;	.)
  	| ">="									(. op = RelOpE.GE;	.)
  	| "<="									(. op = RelOpE.LE;	.)
  	.
  	
  	
  	
  	AddOp<. out AddOpE op .>				(. op = AddOpE.UN;	.)
  	=
  	"+"										(. op = AddOpE.ADD;	.)
  	| "-"									(. op = AddOpE.SUB;	.)
  	| "||"									(. op = AddOpE.OR;	.)
  	.
  	
  	
  	
  	MulOp<. out MulOpE op .>				(. op = MulOpE.UN;	.)
  	=
  	"*"										(. op = MulOpE.MUL;	.)
  	| "/"									(. op = MulOpE.DIV;	.)
  	| "%"									(. op = MulOpE.MOD;	.)
  	| "&&"									(. op = MulOpE.AND;	.)
  	.
  	
  	
  	
  	PostOp<. out PostOpE op .>				(. op = PostOpE.UN;	.)
  	=
  	postInc									(. op = PostOpE.INC;	.)
  	| 
  	postDec									(. op = PostOpE.DEC;	.)
  	.
  	
  	
  	
  	OneVar									(. int type = TableEntry.noType; String name = ""; .)
  	=
  	Ident< out name >						(.
  												TableEntry entry = new TableEntry();
  												entry.name = "__new__";
  												if(table.find(name).type != TableEntry.noType) 
  													SemError("Identifier \"" + name + "\" already declared.");
  												else
  													entry.name = name;
  											.)
  	[
  	"=" Expression< out type >				(.
  												if(!entry.name.equals("__new__"))
  												{
  													entry.kind = TableEntry.Variable;
  													entry.type = type;
  												}
  											.)
  											
  	]										(.
  												if(!entry.name.equals("__new__"))
  													table.insert(entry);
  											.)
  	.
  	
  	
  	
  	DoubleConst<. out double value .>		
  	=
	double									(. try { value = Double.parseDouble(token.val); } catch(NumberFormatException e){value = 0;} .)
  	.
  	
  	IntConst<. out int value .>
  	=
  	number									(. try{value = Integer.parseInt(token.val);} catch(NumberFormatException e){value =  0;} .)
  	.
  	
  
  	Ident<. out String name .>				(. name = ""; .)
  	=
  	identifier								(. name = token.val; .)
  	.
  
  	

END CAL.

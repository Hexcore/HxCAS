import library.*;
import java.util.ArrayList;

COMPILER CAL $NC
static Pair O;
static Table symTable;
static final int noType = 0, intType = 1, boolType = 2;

static class Entity
{
	public String name;
	public int value;
	public int type;
	
	public Entity(String name, int value, int type)
	{
		this.name = name;
		this.value = value;
		this.type = type;
	}
}

static class Table
{
	public ArrayList<Entity> symbols;
	
	
	public Table()
	{
		symbols = new ArrayList<Entity>();
	}
	
	public Entity getSymbol(String name)
	{
		for(int i = 0; i < symbols.size(); i++)
			if(symbols.get(i).name.equals(name))
				return symbols.get(i);
		return null;
	}
	
	public void addSymbol(Entity e)
	{
		symbols.add(e);
	}
}

static class Pair
{
	public int value;
	public int type;
}



static int toInt(boolean b) {
// return 0 or 1 according as b is false or true
  return b ? 1 : 0;
}

static boolean toBool(int i) {
// return false or true according as i is 0 or 1
  return i == 0 ? false : true;
}

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .

TOKENS
  number     = digit { digit } .
  identifier = letter { letter | digit } .

IGNORE CHR(0) .. CHR(31)

PRODUCTIONS
  CAL				(. symTable = new Table(); .)
  =
  { Print
  | Assignment
  } "quit"
  .

  Assignment (. String Name = ""; .)
  =
  Variable<out Name>
  "="
  Expression<out O>
  SYNC ";"					(. if(symTable.getSymbol(Name) == null) symTable.addSymbol(new Entity(Name, O.value, O.type)); else symTable.getSymbol(Name).value = O.value; .)
  .

  Print
  =
  "print"
  Expression<out O>			(. if(O.type == boolType) IO.writeLine(toBool(O.value)); else  IO.writeLine(O.value); .)
  { WEAK ","
    Expression<out O>		(. if(O.type == boolType) IO.writeLine(toBool(O.value)); else  IO.writeLine(O.value); .)
  }
  SYNC ";"
  .

  Expression<.out Pair O .>	(. Pair ExpO; .)
  =								
  AndExp<out O>
  { "||"
    AndExp<out ExpO>	(. 	if(ExpO.type != boolType || O.type != boolType) SemError("O.type Mismatch");
											if(!((new Integer(O.value)).equals(0)) || !((new Integer(ExpO.value)).equals(0))) O.value = 1; else O.value = 0;
											O.type = boolType;
										.)
  } .

  AndExp<. out Pair O .>	(. Pair ExpO; .)
  =
  EqlExp<out O>
  { "&&"
    EqlExp<out ExpO>						(. 	if(ExpO.type != boolType || O.type != boolType) SemError("O.type Mismatch");
											if(!((new Integer(O.value)).equals(0)) && !((new Integer(ExpO.value)).equals(0))) O.value = 1; else O.value = 0;
											O.type = boolType;
										.)
  } .

  EqlExp<. out Pair O .>	(. Pair ExpO; .)
  =
  RelExp<out O>			(. char type = 0; .)
  { EqlOp<out type>
    RelExp<out ExpO>					(.	if(ExpO.type != O.type) SemError("O.type Mismatch");
											switch(type)
											{
												case '=': if(O.value == ExpO.value) O.value = 1; else O.value = 0; break;
												case '!': if(O.value != ExpO.value) O.value = 1; else O.value = 0; break;
											};
											O.type = boolType;
										.)
  } .

  RelExp<. out Pair O .>	(. Pair ExpO; .)
  =
  AddExp<out O>		(. int type = 0; .)
  [ RelOp<out type>
    AddExp<out ExpO>		(. 	if(ExpO.type != O.type) SemError("O.type Mismatch");
												switch(type)
												{	case 1: if(O.value < ExpO.value) O.value = 1; else O.value = 0; break;
													case 2: if(O.value <= ExpO.value) O.value = 1; else O.value = 0; break;
													case 3: if(O.value > ExpO.value) O.value = 1; else O.value = 0; break;
													case 4: if(O.value >= ExpO.value) O.value = 1; else O.value = 0; break;
												}; 
												O.type = boolType;
											.)
  ] .

  AddExp<. out Pair O .>	(. Pair ExpO; .)
  =
  MultExp<out O>	(. char type = 0; .)
  { AddOp<out type>		
    MultExp<out ExpO>					(. 	if(ExpO.type != intType || O.type != intType) SemError("O.type Mismatch");
											switch(type){case '+': O.value += ExpO.value; break; case '-': O.value -= ExpO.value; break;};
										
										.)
  } .

  MultExp<. out Pair O .> (. Pair ExpO; .)
  =
  UnaryExp<out O>	(. char type = 0; .)
  { MulOp<out type>	
    UnaryExp<out ExpO>					(. 	if(ExpO.type != intType || O.type != intType) SemError("O.type Mismatch");
											switch(type){case '*': O.value *= ExpO.value; break; case '/': if(ExpO.value != 0) O.value /= ExpO.value; break; case '%': O.value %= ExpO.value; break;};
										.)
  } .

  UnaryExp<. out Pair O .>	(. O = new Pair(); .)
  =   Factor< out O>
    | "+" UnaryExp<out O>	(. if(O.type != intType) SemError("O.typeMismatch"); .)
    | "-" UnaryExp<out O>	(. if(O.type != intType) SemError("O.typeMismatch"); O.value = -O.value; .)
    | "!" UnaryExp<out O>	(. if(O.type != boolType) SemError("O.typeMismatch"); if((new Integer(O.value)).equals(0)) O.value = 1; else O.value = 0; .)
  .

  Factor<. out Pair O .> (. int Value = 0; String Name = ""; O = new Pair(); .)
  =								
      Variable<out Name>	(. O.value = symTable.getSymbol(Name).value; O.type = symTable.getSymbol(Name).type; .)
    | Number<out Value>		(. O.value = Value; O.type = intType; .)
    | "true"				(. O.value = 1; O.type = boolType; .)
    | "false"				(. O.value = 0; O.type = boolType; .)
    | "(" Expression<out O>
      ")"
  .

  Variable<. out String Name .>
  =
  identifier		(. Name = token.val; .)
  .

  Number<. out int Value .>
  =
  number	(. Value = Integer.parseInt(token.val); .)
  .

  MulOp<. out char type .>	(. type = 0; .)
  =
      "*"	(. type = '*'; .)
    | "/"	(. type = '/'; .)
    | "%"	(. type = '%'; .)
    .

  AddOp<. out char type .>	(. type = 0; .)
  =
      "+"	(. type = '+'; .)
    | "-"	(. type = '-'; .)
  .

  RelOp<. out int type .>	(. type = 0; .)
  =
      "<"		(. type = 1; .)
    | "<="		(. type = 2; .)
    | ">"		(. type = 3; .)
    | ">="		(. type = 4; .)
  .

  EqlOp<. out char type .>	(. type = 0; .)
  =
      "=="	(. type = '='; .)
    | "!="	(. type = '!'; .)
  .

END CAL.

import library.*;
import java.util.ArrayList;
import java.util.TreeSet;
import com.hexcore.cas.rulesystems.TableEntry;
import com.hexcore.cas.rulesystems.ConstantRecord;
import com.hexcore.cas.rulesystems.SymbolTable;
import com.hexcore.cas.rulesystems.PrimaryPair;
import org.objectweb.asm.Label;

COMPILER CAL $NC

static enum RelOpE{LT, GT, LE, GE, EQ, NE, UN};
static enum AddOpE{ADD, SUB, OR, UN};
static enum MulOpE{MUL, DIV, MOD, AND, UN};
static enum PostOpE{INC, DEC, UN};

static SymbolTable table;
static int typeCountExpected = 0;
static int typeCountActual = 0;
static boolean postOpQueued = false;
static PostOpE postOpType;
static boolean valid = true;
static int typeCount = 0;

static public int getErrorCount()
{
	return Errors.count;
}


static public ArrayList<String> getResult()
{
	ArrayList<String> results = Parser.getErrorList();
	if(Parser.getErrorCount() == 0)
		results.add("Compiled Successfully");
	
	return results;
}


static ArrayList<String> getErrorList()
{
	ArrayList<String> results = new ArrayList<String>();
		
	ErrorRec current = Errors.first;
	
	while(current != null)
	{
		results.add("Error at line " + current.line + ": " + current.str);
		current = current.next;
	}
	
	return results;
}

static void SemanticError(String msg)
{
	valid = false;
	SemError(msg);
	System.err.println("SEM ERROR");
}

static byte[] getCode()
{
	return CodeGen.getCode();
}

static public void reset()
{
	errDist = minErrDist;
	Errors.count = 0;
	Errors.first = null;
	Errors.last = null;
	Errors.eof = false;
	valid = true;
}

CHARACTERS
  digit      = "0123456789" .
  letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" .
  lf = CHR(10) .

TOKENS
  number	= digit { digit } .
  double	= digit {digit}"."digit{digit} .
  postInc	= "++" .
  postDec	= "--" .
  
  identifier = letter { letter | digit } .
  
COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO lf

IGNORE CHR(0) .. CHR(31)


PRODUCTIONS
	/********* File Root *********/
	CAL										(. 	
												table = new SymbolTable();
												typeCount = 0;
											.)				
  	=
  	RuleSet									(. 	
  												if(typeCount != typeCountExpected)
  												{
  													SemanticError("Mismatch between declared and actual type count");
  												}
  												
  												if(valid)
  												{
  													CodeGen.endExecute();
  													CodeGen.endClass();
  												}
  											.)
  	.
  	/*****************************/
  	
  	
  	
	/********** RuleSet **********/
  	RuleSet									(.
  												String name = "";
  												table.pushScope();
  												table.prepare();
  											.)
  	=
  	"ruleset" Ident< out name >				(. 	
  												if(valid)
  												{
  													CodeGen.initClass(name);
  													CodeGen.initExecute();
  												}
  											.)
  	"{"
	  	TypeCount
	  	Property {Property}
	  	TypeSpec {TypeSpec}
  	"}"
  	.
  	/*****************************/
  	
  	
  	
  	
  	/********** Type Count Declaration **********/
  	TypeCount								(. int value = 0; .)
  	=
  	"typecount" IntConst< out value >		(.
  												if(value < 1)
  												{
  													SemanticError("At least one type of cell must be declared");
  												}
  												typeCountExpected = value;
  												
  												if(valid)
  													CodeGen.initFramework(typeCountExpected);
  											.)
  	";"
  	.
	/********************************************/
  	
  	
  	/********** Cell Property **********/
  	Property								(. String name = ""; .)
  	=
  	"property" Ident< out name >			(.
  												if(table.find(name).type != TableEntry.noType) SemanticError("Identifier \"" + name + "\" already declared.");
  												TableEntry entry = new TableEntry();
  												entry.name = name;
  												entry.type = TableEntry.doubleType;
  												entry.kind = TableEntry.Property;
  												if(valid)
  													entry.offset = CodeGen.declareProperty(name);
  												table.insert(entry);
  											.)  
  	";"
  	.
  	/***********************************/
  	
  	
  	
  
  	
  	/********** Type Specification **********/
  	TypeSpec								(.
  												table.pushScope();  												
  											.)
  	=
  	"type" identifier
  											(.
  												if(typeCount >= typeCountExpected)
  												{
  													SemanticError("Too many types");
  												}
  												typeCount++;
  												if(valid)
  													CodeGen.initType();
  											.)
  	"{"
  		{Statement}
  	"}"										(.
  												table.popScope();
  												
  												if(valid)
  													CodeGen.endType();
  											.)
  	.
  	/****************************************/
  	
  	
  	
  	
  	/********** Statement Block **********/
  	Block 
  	=
  	"{"										(. table.pushScope(); .)
  		{Statement}
  	"}"										(. table.popScope(); .)
  	.
  	/*************************************/
  	
  	
  	
  	
  	
  	/********** STATEMENT **********/
  	Statement
  	=
  	 Block
  	 | AssignCall
  	 | IfStatement
  	 | Loop
  	 | VarDeclaration 
  	.
  	/*******************************/
  	
  	
  	/********** Assignment or function call *********/
  	AssignCall									(. TableEntry entry = null; int type = TableEntry.noType; int typeA = TableEntry.noType;.)
  	=
  	Designator< out entry, false >			(. PostOpE T = PostOpE.UN; .)
  	(
  		"=" Expression< out type >				(. 	
  													if(!(TableEntry.isArith(entry.type) && TableEntry.isArith(type)) && !(TableEntry.isBool(entry.type) && TableEntry.isBool(type)))
  													{
  														SemanticError("Incompatable Types");
  													}
  													else if(!(TableEntry.isArray(entry.type) && TableEntry.isArray(type)) && !(!TableEntry.isArray(entry.type) && !TableEntry.isArray(type)))
  													{
  														SemanticError("Cannot mix scalar and array types in assignment");
  													}
  													
  													if(valid)
  													{
	  													if(entry.kind == TableEntry.Variable)
	  													{
	  														if(TableEntry.isBool(type))
	  															CodeGen.toDouble();
	  														CodeGen.storeVariable(entry.offset);
	  													}
	  													else if(entry.kind == TableEntry.Property)
	  													{
	  														CodeGen.storeProperty(entry.offset);
	  													}
  													}
  												.)
  		| PostOp< out T >						(. 
  													if(!TableEntry.isArith(entry.type))
  														SemanticError("Cannot perform a post operation on a boolan type.");
  														
  													if(entry.kind != TableEntry.Variable)
  													{
  														SemanticError("Can only perform post operation on a variable.");
  													}
  													else
  													{
  														if(valid)
  														{
	  														if(T == PostOpE.INC)
	  															CodeGen.performPostOp(entry.offset, 1);
	  														else
	  															CodeGen.performPostOp(entry.offset, -1);
  														}
  													}
  												.)
  		| "(" Arguments< out typeA >			(.	if(!TableEntry.isFunction(entry.kind))
  												{
  													SemanticError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemanticError("Invalid argument. Argument must be an array");
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemanticError("Invalid argument. Argument must be a scalar type");
  													}
  												}
  											.)
  		
  		")"
  	)
  	";"
  	.
  	/*************************************************/
  	
  	
  	
  	
  	/********** Declared Designator *********/
  	Designator<. out TableEntry entry, boolean attr .>	(.
			  													int type = TableEntry.noType;
			  													int typeE = TableEntry.noType;
			  													String name = "";
			  													TableEntry entryA = null;
			  												.)
  	=
  	Ident< out name >							(.

  													entry = table.find(name);
  													if(entry.type == TableEntry.noType)
  														SemanticError("Undeclared identifier \"" + name + "\"");
  													else
  														type = entry.type;
  														
  													if(entry.kind == TableEntry.Property && attr == false)
  														SemanticError("Properties must be called with \"self\"");
  														
  														
  													if(entry.kind == TableEntry.Cell)
  														if(valid)
		  													CodeGen.derefRef(entry.offset);
  														
  												.)
  													 
  	[
  		"["												
  			Expression< out typeE >				(. if((type % 2) == 0) SemanticError("Cannot index scalar type \"" + name +  "\"");
  													if(!TableEntry.isArith(typeE))
  													{
  														SemanticError("Index must be arithmetic");
  													}
  													
  													if(valid)
  														CodeGen.derefArrayRef();
  												.)
  												
  												
  		"]"										(.
  													if(!TableEntry.isArray(type))
  													{
  														SemanticError("Can only index arrays");
  													}
  													TableEntry entryS = new TableEntry();
  													entryS.name = entry.name;
  													entryS.kind = entry.kind;
  													entryS.type = entry.type - 1;
  													entry = entryS;
  												.)
  	]
  	[  	
  		"." Attribute< out entryA > 				(.
  														if(entry.kind != TableEntry.Cell) SemanticError("Only cells have attributes.");
  														if(entryA.kind != TableEntry.Property) SemanticError("Only declared properties can be used as cell attributes.");
  														TableEntry entryAA = new TableEntry();
  														entryAA.name = entryA.name;
  														entryAA.kind = entryA.kind;
  														entryAA.offset = entryA.offset;
  														if(TableEntry.isArray(entry.type))
  														{
  															entryAA.type = entryA.type + 1;
  														}
  														else
  														{
  															entryAA.type = entryA.type;
  														}
  														
  														entry = entryAA;
  													.)
  	]
  	.
  	/****************************************/
  	
  	
  	
  	/********** Cell Attribute *********/
  	Attribute<. out TableEntry entry .>
  	=
  	Designator< out entry, true >
  	.
  	/***********************************/
  	
  	
  	
  	/********** If Statement *********/
  	IfStatement									(. int type = TableEntry.noType; .)
  	=
  	"if" "("
  	Expression< out type > 
  	")"											(. 
  													Label[] pointers = null;	
  													if(valid)
  													{	
  														pointers = CodeGen.initIf();
  													}
  												.)
  												
  	Statement									(.
  													if(valid)
  													{
  														CodeGen.jump(pointers[1]); 
  														CodeGen.visitLabel(pointers[0]);
  													}
  												.)
  	[
  	"else" Statement							
  	]											(.
  													if(valid)
  														CodeGen.visitLabel(pointers[1]);
  												.)
  	.
  	/*********************************/
  	
  	
  	/********** Loop *********/
  	Loop										(.
  													int type1 = 0, type2 = 0;
  													String name = "";
  													Label[] loopLabels = null;
  													TableEntry entry = new TableEntry();
  												.)
  	=
  	"loop" Ident< out name > 					(.
  													if(table.find(name).type != TableEntry.noType)
  													{
  														SemError("Redeclared identifier");
  													}
  													
  													if(valid)
  													{  														
  														entry.kind = TableEntry.Variable;
  														entry.name = name;
  														entry.type = TableEntry.intType;
  														table.insert(entry);
  														entry.offset = CodeGen.declareLoopVariables();
  													}
  												.)
  	"from" Expression< out type1 > 
  	"to" Expression< out type2 >				(.
  													if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  													{
  														SemError("Loop bounds must be arithmetic expressions");
  													}
  													
  													if(TableEntry.isArray(type1) || TableEntry.isArray(type2))
  													{
  														SemError("Loop bounds must be scalar");
  													}
  													
  													if(valid)
  													{
  														loopLabels = CodeGen.initLoop(entry.offset);
  													}
  												.)
  	"{"
  		Statement
  	"}"											(.
  													if(valid)
  														CodeGen.endLoop(loopLabels, entry.offset);
  												.)
  	.
  	/*************************/
  	
  	
  	
  	/********** Variable Declaration *********/
  	VarDeclaration
  	=
 	"var"
	OneVar
	{
	"," OneVar
	}
	";"
	.
  	
  	/*****************************************/
  	
  	
  	
  	/********** Expression **********/
  	Expression<. out int type .>			(. 	int type1, type2;
  												type = TableEntry.noType;
  											.)
  	=
  	AddExp< out type1 >						(.
  												RelOpE op = RelOpE.UN;
  												type = type1;
  											.) 
  	[
  	RelOp< out op >							
  	AddExp< out type2 >						(.
  												if(!(TableEntry.isArith(type1) && TableEntry.isArith(type2)) && !(TableEntry.isBool(type1) && TableEntry.isBool(type2)))
  												{
  													SemanticError("Type mismatch");
  													type = TableEntry.noType;
  												}
  													
  												type = TableEntry.boolType;
  												
  												if(valid)
  													CodeGen.performRelationalOp(op);										
  											.)
  	]
  	.
  	/********************************/
  	
  	
  	
  	/********** Add-Based Expression **********/
  	AddExp<. out int type .>				(.
  												int type1, type2;
  												type = TableEntry.noType;
  												boolean negative = false;
  											.)
  	=
  	["+" | "-"								(. negative = true; .)
  	]
  	Term< out type1 >						(.
  												AddOpE op = AddOpE.UN;
  												type = type1;
  												
  												if(negative)
  												{
	  												if(!TableEntry.isArith(type1))
	  													SemanticError("Cannot negate a boolean type");
	  												else
	  													if(valid)
	  														CodeGen.negate();
  												}
  											.)
  	{
  	AddOp< out op > 
  	Term< out type2 >						(.
  												switch(op)
  												{
  													case OR:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemanticError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemanticError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;
  												}
  												
  												if(valid)
  													CodeGen.performAddOp(op);
  											.)
  	}
  	.
  	/******************************************/
  	
  	
  	
  	
  	
  	/********** Terms **********/
  	Term<. out int type .>					(.
  												int type1, type2;
  												type = TableEntry.noType; 
  											.)
  	=
  	Factor< out type1 >						(.
  												MulOpE op = MulOpE.UN;
  												type = type1;
  											.)
  	{
  	MulOp< out op >					
  	Factor< out type2 >						(.
  												switch(op)
  												{
  													case AND:
  														if(!TableEntry.isBool(type1) || !TableEntry.isBool(type2))
  															SemanticError("Boolean Types Required");
  														type = TableEntry.boolType;
  														break;
  													default:
  														if(!TableEntry.isArith(type1) || !TableEntry.isArith(type2))
  															SemanticError("Numeric Types Required");
  														if((type1 == TableEntry.intType) && (type2 == TableEntry.intType))
  															type = TableEntry.intType;
  														else
  															type = TableEntry.doubleType;  														
  												}
  												
  												if(valid)
  													CodeGen.performMulOp(op);
  											.)
  	}
  	.
  	/**********************************/
  	
  	
  	
  	
  	
  	
  	/********** Factors **********/
  	Factor<. out int type .>				(.
  												PostOpE T = PostOpE.UN;
  												PrimaryPair p = new PrimaryPair();
  											.)
  	=
  	Primary< out p >						(. type = p.type; .)
  	[
  	PostOp< out T >							(.
  												if(!TableEntry.isArith(type)) SemanticError("Cannot perform a post operation on a boolan type.");
  												if(p.kind != TableEntry.Variable)
  												{
  													SemanticError("Can only perform post operations on a variable.");
  												}
												else
												{
													if(valid)
													{
														if(T == PostOpE.INC)
														{
															CodeGen.performPostOp(p.offset, 1);
														}
														else
														{
															CodeGen.performPostOp(p.offset, -1);
														}
													}
												}
  											.)
  	]
  	.
  	/*****************************/
  	
  	
  	
  	/********** PRIMARY ELEMENT **********/
  	Primary<. out PrimaryPair p .>			(.
  												p = new PrimaryPair();
  												p.type = TableEntry.noType;
  												
  												int typeA = TableEntry.noType;
  												int typeE = TableEntry.noType;
  												
  												ConstantRecord con;
  												TableEntry entry = null;
  											.)
  	=
  	Designator< out entry, false >		(.
  												p.type = entry.type;
  												p.kind = TableEntry.Variable;
  												p.offset = entry.offset;
  												
  												
  												if(valid)
  												{
	 												if(entry.kind == TableEntry.Variable)
			  											CodeGen.derefVariable(entry.offset);		  											 
			  										else if(entry.kind == TableEntry.Property)
			  										{
			  											if(TableEntry.isArray(entry.type))
			  												CodeGen.generatePropertyArray(entry.offset);
			  											else
			  												CodeGen.derefProperty(entry.offset);
			  										}
			  									}
  											.)
  	[
  	"("		
  		Arguments< out typeA >				(.	
   												if(!TableEntry.isFunction(entry.kind))
  												{
  													SemanticError("Arguments can only be given to a function.");
  												}
  												
  												if(entry.kind == TableEntry.aFunction)
  												{
  													if(!TableEntry.isArray(typeA))
  													{
  														SemanticError("Invalid argument. Argument must be an array");
  													}
  													else
  													{
  														if(valid)
  															CodeGen.invokeStandardArrayMethod(entry.name, entry.argType, entry.type);
  													}
  												}
  												else
  												{
  													if(TableEntry.isArray(typeA))
  													{
  														SemanticError("Invalid argument. Argument must be a scalar type");
  													}
  													else
  													{
  														if(valid)
  															CodeGen.invokeStandardScalarMethod(entry.name, entry.argType, entry.type);
  													}
  												}
  												p.kind = TableEntry.Constant;
  											
  											.)
  	")"										
  	]										
  	|
  	Constant< out con >						(.
  												p.type = con.type;
  												p.kind = TableEntry.Constant;
  												
  												if(valid)
  													CodeGen.loadConstant((double)con.value);
  											.)
  	|
  	"(" Expression< out typeE >				(.
  												p.type = typeE;
  												p.kind = TableEntry.Constant;
  											.)
  	")"										
  	.
  	/*************************************/
  	
  	
  	
  	
  	/********** Contant **********/
  	Constant<. out ConstantRecord con .>	(. 	
  												con = new ConstantRecord();
  											.)
  	=
  	DoubleConst< out con.value >			(.	con.type = TableEntry.doubleType;	.)
	| IntConst< out con.value >				(.	con.type = TableEntry.intType;		.)
  	.
  	/*****************************/
  	
  	
  	
  	
  	/********** ARGUMENTS **********/
  	Arguments<. out int type .>				(. type = TableEntry.noType; .)
  	=
  	[
  		Expression< out type >
  		
  		/*
  		Current version support and requirement for only one argument
  		{"," Expression< out type >
  		}*/
  	]
  	.
  	/*******************************/
  	
  	
  	
  	
  	/********** Operators **********/
  	RelOp<. out RelOpE op .>				(. op = RelOpE.UN;	.)
  	=
  	"=="									(. op = RelOpE.EQ;	.)
  	| "!="									(. op = RelOpE.NE;	.)
  	| ">"									(. op = RelOpE.GT;	.)
  	| "<"									(. op = RelOpE.LT;	.)
  	| ">="									(. op = RelOpE.GE;	.)
  	| "<="									(. op = RelOpE.LE;	.)
  	.
  	
  	
  	
  	AddOp<. out AddOpE op .>				(. op = AddOpE.UN;	.)
  	=
  	"+"										(. op = AddOpE.ADD;	.)
  	| "-"									(. op = AddOpE.SUB;	.)
  	| "||"									(. op = AddOpE.OR;	.)
  	.
  	
  	
  	
  	MulOp<. out MulOpE op .>				(. op = MulOpE.UN;	.)
  	=
  	"*"										(. op = MulOpE.MUL;	.)
  	| "/"									(. op = MulOpE.DIV;	.)
  	| "%"									(. op = MulOpE.MOD;	.)
  	| "&&"									(. op = MulOpE.AND;	.)
  	.
  	
  	
  	
  	PostOp<. out PostOpE op .>				(. op = PostOpE.UN;	.)
  	=
  	postInc									(. op = PostOpE.INC;	.)
  	| 
  	postDec									(. op = PostOpE.DEC;	.)
  	.
  	/*******************************/
  	
  	
  	
  	
  	
  	/********** Single Variable **********/
  	OneVar									(. int type = TableEntry.noType; String name = ""; .)
  	=
  	Ident< out name >						(.
  												TableEntry entry = new TableEntry();
  												entry.name = "__new__";
  												
  												if(table.find(name).type != TableEntry.noType) 
  													SemanticError("Identifier \"" + name + "\" already declared.");
  												else
  												{
  													entry.kind = TableEntry.Variable;
  													entry.name = name;
  													entry.offset = CodeGen.declareLocalVariable(name);
  												}
  											.)
  	[
  	"=" Expression< out type >				(.
  												if(!entry.name.equals("__new__"))
  												{
  													entry.kind = TableEntry.Variable;
  													entry.type = type;
  												}
  												
  												if(valid)
  													CodeGen.storeVariable(entry.offset);
  											.)
  											
  	]										(.
  												if(!entry.name.equals("__new__"))
  													table.insert(entry);
  											.)
  	.
  	/*************************************/
  	
  	
  	
  	
  	/********** Double Constant **********/
  	DoubleConst<. out double value .>		
  	=
	double									(.
												try
												{
													value = Double.parseDouble(token.val);
												} catch(NumberFormatException e)
												{
													value = 0;
												}
												
											.)
  	.
  	/*************************************/
  	
  	
  	
  	/********** Integer Constant **********/
  	IntConst<. out int value .>
  	=
  	number									(.
  												try
  												{
  													value = Integer.parseInt(token.val);
  												}
  												catch(NumberFormatException e)
  												{
  													value =  0;
  												} 
  											.)
  	.
  	/**************************************/
	
	
	
	/********** Identifier **********/
  	Ident<. out String name .>				(.
  												name = "";
  											.)
  	=
  	identifier								(.
  												name = token.val;
  											.)
  											
  	|
  	"type"									(. name = "type"; .)
  	.
	/********************************/
  	

END CAL.
